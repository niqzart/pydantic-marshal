from typing import Any, ClassVar

from pydantic import BaseModel, create_model

from pydantic_marshals.fields.base import MarshalField


class MarshalBaseModel(BaseModel, from_attributes=True, populate_by_name=True):
    pass


class MarshalModel:
    """
    Basic boilerplate class for all pydantic-marshals models.
    This is a complete class, but it could be extended with alternative constructors,
    updated base model, new runtime methods or auto-converters for fields
    """

    def __init__(
        self,
        *fields: MarshalField,
        bases: list[type[BaseModel]],
    ) -> None:
        """
        :param fields: fields to include in the model
        :param bases: pydantic bases to add to the model
        """
        self.fields: list[MarshalField] = list(fields)
        self.bases: list[type[BaseModel]] = bases
        self._generated_model: type[BaseModel] | None = None

    def __set_name__(self, owner: type, name: str) -> None:
        self.model_name: str = f"{owner.__qualname__}.{name}"

    model_base_class: ClassVar[type[BaseModel]] = MarshalBaseModel
    """Base model class. Subclasses of :py:class:`MarshalBaseModel` are recommended"""

    def generate_base(self) -> type[BaseModel] | tuple[type[BaseModel], ...]:
        """Generate __base__ argument for :py:func:`create_model`"""
        return self.model_base_class, *self.bases

    def generate_model(self) -> type[BaseModel]:
        """Generate the pydantic model"""
        return create_model(  # type: ignore[call-overload, no-any-return]
            self.model_name,
            __base__=self.generate_base(),
            **{
                mapped_field.generate_name(): mapped_field.generate_field()
                for mapped_field in self.fields
            },
        )

    @property
    def generated_model(self) -> type[BaseModel]:
        """
        Pydantic model, generated by the MarshalModel
        First call to this will call :py:meth:`.generate_model`,
        then save the result to :py:attr:`._generated_model`,
        for it to be reused on future calls
        """
        if self._generated_model is None:
            self._generated_model = self.generate_model()
        return self._generated_model

    def __get__(
        self,
        instance: Any,  # noqa: U100
        owner: Any | None = None,  # noqa: U100
    ) -> type[BaseModel]:
        return self.generated_model
